/*#include "iom128v.h"
#include "macros.h"
void delay(int t)
{
	int c1,c2;
	for(c1=0;c1<t;c1++)
    {
    	for(c2=0;c2<970;c2++)
        {
        	NOP();
        }
    }
}

char scan_buttons() // функция считывания состояния с кнопок
{
  char t, d=0;
  DDRA=0;		   // порт А настроен на вход для считывания данных с кнопок
  PORTD=0x80;	   // уст. лог. 1 на выводе PD7 для управления регистром клавиатуры
  t=PINA;		   // считывание значения с шины данных
  PORTD=0;		   // перевод регистра клавиатуры в высокоимпедансное состояние
  DDRA=0xFF;	   // настройка порта А на выход
  DDRG=0x01;	   // разрешение работы дешифратора
  PORTG=0;	 	   // установка на выходе PG0 лог. 0
  // преобразование данных, полученных с кнопок для удобства использования
  if((t&0x10)==0) d=1;	
  if((t&0x20)==0) d=-1;
  if((t&0x40)==0) d=0;
  if((t&0x80)==0) d=1;
  if((t&0x01)==0) d=1;
  if((t&0x02)==0) d=1;
  if((t&0x04)==0) d=1;
  if((t&0x08)==0) d=1;
  return d;	  // значение возвращается из функции с инверсией
}

void main()
{
 	char seg[10]={0b01110111, 0b01100000, 0b00111110, 0b01111010, 0b01101001,
0b01011011, 0b01011111, 0b01110000,0b01111111, 0b01111011};
int i,t;
DDRC=0b10000111; // ?????????? ???????????? ???? ??????
DDRA=0xFF; // ???? ??????
DDRG=0x01; // ?????????? ?????? ???????????
PORTG=0; // ????????? ?? ?????? PG0 ???. 0
PORTA=0; // ????????? ???????? ?????????? ??????????
PORTC=0; // ???????? ???????
PORTC=5; // ???????? ??????
while(1)
{
 t=scan_buttons();
 if(t==1)i++;
 else if(t==-1)
 {
  if(i==0) {i=9999;}
  i--;
 }

 else if(t==0)i=0;
 PORTC=6; // ????????? ?????????? ?6
 PORTA=~seg[i/1000]; //????? ? ???? ???????? ?????
 PORTC=7; // ????????? ?????????? ?7
 PORTA=~seg[(i%1000)/100]; //????? ? ???? ???????? ?????
 PORTC=1; // ????????? ?????????? ?8
 PORTA=~seg[((i%1000)%100)/10]; //????? ? ???? ???????? ???????
 PORTC=2; // ????????? ?????????? ?9
 PORTA=~seg[((i%1000)%100)%10]; //????? ? ???? ???????? ?????? 

 }
}
*/

#include "iom128v.h"
#include "macros.h"
void delay(int ms) // функция формирования временной задержки
{
int c1, c2; // объявление дополнительных переменных
for(c1=0;c1<ms;c1++)
for(c2=0;c2<970;c2++) NOP(); // в цикле выполняется &quot;пустая&quot; операция
}
char scan_buttons() // функция считывания состояния с кнопок
{
char t, d=255;
DDRA=0; // порт А настроен на вход для считывания данных с
PORTD=0x80; // уст. лог. 1 на выводе PD7 для управления регистром
t=PINA; // считывание значения с шины данных
PORTD=0; // перевод регистра клавиатуры в высокоимпедансное
DDRA=0xFF; // настройка порта А на выход
DDRG=0x01; // разрешение работы дешифратора
PORTG=0; // установка на выходе PG0 лог. 0
if((t&0x10)==0) d=~0x80;
if((t&0x20)==0) d=~0x40;
if((t&0x40)==0) d=~0x20;
if((t&0x80)==0) d=~0x10;
if((t&0x01)==0) d=~0x01;
if((t&0x02)==0) d=~0x02;
if((t&0x04)==0) d=~0x04;
if((t&0x08)==0) d=~0x08;
return ~d; // значение возвращается из функции с инверсией
}

void main()
{
char t;
char c=0, r=0;
DDRC=0b10000111; // управление дешифратором шины данных
DDRA=0xFF; // порт А настраивается на выход
PORTA=0; // вывод значения 0 на шину
PORTC=0; // отключение строк матричного индикатора
PORTC=5; // отключение столбцов матричного индикатора
DDRD=0x80; // линия управления регистром тактовых кнопок
PORTC=4; // включение регистра светодиодов
while(1)
{
t=scan_buttons(); // получение данных с кнопок
if(((t&0x01)!=0)&& (c<7)) c++;
if(((t&0x02)!=0)&& (c>0)) c--;
if(((t&0x80)!=0)&& (r>0)) r--;
if(((t&0x40)!=0)&& (r<7)) r++;
PORTC=5;
PORTA=(1<<r);
PORTC=0;
PORTA=~(1<<c);
delay(500);
}
}


